---
title: "Cartographie th√©matique avec {ojs}"
subtitle: "√âcole d'√©t√© internationale, Ouidah, 2023"
author: "Nicolas Lambert, Manhamady Ouedraogo"
date: 03/08/2023
date-format: "DD MMM YYYY"
title-slide-attributes:
  data-background-color: black
  data-background-image: img/nice.jpg
  data-background-size: cover
  data-background-opacity: "0.5"
format:
  revealjs:
    embed-resources: true
    smaller: true
    scrollable: true
    theme: [simple, custom.scss]
    code-line-numbers: false
editor: visual
execute:
  echo: true
---

# 

**Responsables p√©dagogiques**

Manhamady OUEDRAOGO (Burkina Faso) & Nicolas LAMBERT (France)

**Ont particip√© √† l'√©laboration de ce module**

Claude GRASLAND (France), Souleymane Sidi TRAORE (Mali), Malika MADELIN (France), S√©bastien REY-COYREHOURCQ (France), Vakaramoko BAMBA (C√¥te d'Ivoire), Hugues PECOUT (France), Yentougle MOUTORE (Togo), B√©n√©dicte GARNIER (France), C√¥omlan Charles HOUNTON (B√©nin), Pauline GLUSKI (France)

# Introduction

::: notes
Cette introduction pose des √©l√©ments de contexte sur l'histoire de la dataviz et les √©volutions technologiques r√©centes. Pour en savoir plus : https://observablehq.com/@tophtucker/classic-research-in-data-visualization
:::

## Petite histoire de la cartographie

Les premi√®res cartes

::: columns
::: {.column width="49%"}
<img src="img/Bedolina.jpg" style="border:none"/></img><br/> "Cadastre" de <b>Bedolina</b> (d√©couverte en en Italie du nord) 2000 ans av.n.√®. J.-C. Quatre p√©riodes au moins de gravure se superposent, et cette myst√©rieuse topographie appara√Æt sur la deuxi√®me couche, voisinant avec des repr√©sentations de cervid√©s. S'il s'agit bien d'un premier vocabulaire topographique, nous ne savons pas le lire.<br/>
:::

::: {.column width="49%"}
<img src="img/Mattangs.jpeg" style="border:none"/></img><br/> Ces cartes polyn√©siennes appel√©es <b>Rebbelibs</b>, <b>Medosou</b> ou <b>Mattangs</b> repr√©sentants les courants marins et la direction de la houle qui est perturb√©e par la pr√©sence des √Æles avec des batons de bois courb√©s, les coquillages repr√©sentants la position des √Æles. Elle datent de 1000 av.n.√®.
:::
:::

### Des repr√©sentations du Monde qui s'affinent

<img src="img/I.01.histoire.png"/></img>

*Lambert, N., Zanin C. (2019). Mad Maps - L'Atlas qui va changer votre vision du monde (p. 144p). Armand Colin.*

::: notes
L'humanit√© produit des cartes depuis plus de 4000 ans pour se rep√©rer et/ou se d√©placer. Petit √† petit les repr√©sentations du monde se sont affin√©es. On dispose aujourd'hui de bases de donn√©es tr√®s pr√©cises permetant de repr√©senter le monde. Est-ce "la fin de l'histoire" cartographique ?
:::

## Les d√©buts de la dataviz

::: {align="center"}
<b>Nicole Oresme</b> (1370) est un des premiers √† concevoir le principe et l'utilit√© des coordonn√©es cart√©siennes pour la repr√©sentation graphique de ph√©nom√®nes quantitatifs

::: columns
::: {.column width="49%"}
<img src="img/oresme1.png" style="border:none"/></img>
:::

::: {.column width="49%"}
<img src="img/oresme2.png" style="border:none"/></img>
:::
:::

<b>William Playfair</b> (1786)<br/>Commercial and Political Atlas.<br/>

::: columns
::: {.column width="49%"}
<img src="img/Playfair1.png" style="border:none"/></img>
:::

::: {.column width="49%"}
<img src="img/Playfair2.png" style="border:none"/></img>
:::
:::

<b>Florence Nightingale</b> (1857)<br/>Notes on Matters Affecting the Health, Efficiency and Hospital Administration of the British Army.<br/>

<img src="img/Nightingale.png" style="border:none"/></img>
:::

::: notes
On va s'interesser maintenant √† une autre histoire, celle de la visualisation de donn√©es. Cette histoire est plus courte. Elle commence vraiment au 18e siecle avec William Playfair et Florence Nightingale.
:::

## La rencontre de 2 mondes

Quand la cartographie rencontre la visualisation de donn√©es statistiques

::: {align="center"}
::: columns
::: {.column width="49%"}
Carte figurative de l'instruction populaire en France (<b>Charles Dupin</b>, 1826) <img src="img/Dupin.png" style="border:none"/></img><br/>
:::

::: {.column width="49%"}
<b>Fr√®re de Montizon</b> (1830)<br/> <img src="img/Montizon.png" style="border:none"/></img> <b>Emile Cheysson</b> (1886) <img src="img/Cheysson.png" style="border:none"/></img><br/>
:::
:::

### Le <i>GOLD STANDARD</i> de la dataviz

<img src="img/Minard.png" style="border:none"/></img>

Carte Figurative des pertes successives en hommes de l'arm√©e fran√ßaise dans la campagne de Russie 1812--1813.<br/>Charles Joseph Minard (1869). <b>Minard</b> repr√©sente en 1869 les pertes colossales de l'arm√©e fran√ßaise dans la campagne de Russie au d√©but du XIXe si√®cle. Cette fameuse ¬´ carte figurative ¬ª raconte l'histoire de cette arm√©e, qui arrive √† Moscou avec moins d'un quart de son effectif de d√©part, avant de se faire √† nouveau d√©cimer sur le voyage du retour.
:::

::: notes
Ces deux histoires s'intersectent pour la premi√®re fois en 1826 avec la carte figurative de Charles Dupin. Pour la premi√®re fois, on repr√©sentatait des donn√©es statistiques sur un rep√®re g√©ographique. C'est aussi la premi√®re carte choropl√®the. S'en suivent de nombreuses autres repr√©sentations cartographiques. Les r√©alisations de C.J. Minard sont particuli√®rement remarquables.
:::

## Bertin, 1967 (et 1973)

-   Enorme travail de synth√®se.
-   Approche plut√¥t pragmatique.
-   Pour le papier.
-   En noir et blanc.
-   Mais un travail qui reste central pour toutes celles et ceux qui travaillent sur la visualisation de donn√©es aujourd'hui.

<img src="img/semio.png" style="border:none"/></img>

::: notes
Cette fa√ßon de repr√©senter des donn√©es via des signes graphiques et systh√©tis√©e de fa√ßon remarquable en 1967 par Jacques Bertin.
:::

## R√©volutions technologiques

<div align = "center">

::: columns
::: {.column width="49%"}
Les ordinateurs <img src="img/ordinateur.png" style="border:none"/></img>
:::

::: {.column width="49%"}
Internet <img src="img/internet.png" style="border:none"/></img>
:::
:::

::: footer
https://observablehq.com/@tophtucker/classic-research-in-data-visualization
:::

::: notes
Puis, intervient la r√©volution num√©rique. De nouvelles technologies mais qui ne remettent pas fondamentalement en causes la th√©orie de la s√©miologie graphique.
:::

##  {background-image="img/leaflet.jpg" background-size="contain"}

::: footer
<b>Leaflet, 2010</b><br/> https://leafletjs.com/
:::

##  {background-image="img/deckgl.png" background-size="contain"}

::: footer
<b>Deck.gl, 2015</b><br/> https://deck.gl/
:::

##  {background-image="img/keplergl.png" background-size="contain"}

::: footer
<b>KeplerGL, 2018</b><br/> https://kepler.gl/
:::

##  {background-image="img/bostock2011.png" background-size="contain"}

::: footer
<b>Shan Carter, 2012 (D3.js - Mike Bostock)</b><br/> https://archive.nytimes.com/www.nytimes.com/interactive/2012/02/13/us/politics/2013-budget-proposal-graphic.html
:::

##  {background-image="img/vegalite.png" background-size="contain"}

::: footer
<b>Vega-lite, 2013</b><br/> https://vega.github.io/
:::

##  {background-image="img/plot.png" background-size="contain"}

::: footer
<b>Observable Plot, 2022</b><br/> https://github.com/observablehq/plot
:::

##  {background-image="img/bertin.png" background-size="contain"}

::: footer
<b>Bertin, 2022</b><br/> https://github.com/neocarto/bertin
:::

# JavaScript üñ•Ô∏è

::: notes
Nous allons parler √† pr√©sent du langage JavaScript. Points cl√©s : c'ets un vieux langage qui n'a pas √©t√© concu pour l'analyse de donn√©es. Mais c'ets le langage du web. Il fonctionne sur tous les navigateurs web sans avoir besoin d'installer quoi que ce soit. Ce langage peut √™tre √©tendu pour devenir un langage d√©di√© √† la dataviz.
:::

## Historique

Le JavaScript est un langage de programmation qui a presque 30 ans.

### 1995

![](img/javascript.png){height="100"}

Le langage Javascript a √©t√© cr√©√© en dix jours en mai 1995 pour la Netscape Communications Corporation par **Brendan Eich**. Au d√©part, l'id√©e √©tait de construire un petit langage pour faire des interactions sur les pages web. Attention, Javascript n'est pas JAVA !

### 1997

![](img/ecma.png){height="65"}

Le langage Javascript est normalis√© depuis 1997 par la commission TC39 de l'organisation ECMA International.

### 2008

Les navigateurs web ont travaill√© √† de nouveaux moteurs pour am√©liorer les performances. **V8** est un moteur JavaScript open-source d√©velopp√© par le projet Chromium pour les navigateurs Web Google Chrome et Chromium (derni√®re version 31 janvier 2022). Il y a aussi **SpiderMonkey** pour Firefox, **Chakra** pour Microsoft Edge et **JavaScriptCore** pour Safari.

### 2009

![](img/node.png){height="100"}

Cr√©ation de Node.js par **Ryan Dahl**, qui permet d'utiliser le JavaScript comme langage de programmation c√¥t√© serveur (back-End).

### 2015

Depuis 2015 (ES6 ou ES2015), le langage JavaScript est mature. Performant. Et est impl√©ment√© de mani√®re harmonis√©e dans tous les navigateurs. On parle de *modern JavaScript*

### demain ?

De nouvelles fonctionnalit√©es sont ajout√©es au langage chaque ann√©e.

Voir : [observablehq.com/\@robertbatty/ecmascript-2015-2022](https://observablehq.com/@robertbatty/ecmascript-2015-2022)

## Une grande communaut√©

C'est un langage ancien qui dispose d'une tr√®s grande communaut√©.

::: columns
::: {.column width="49%"}
JavaScript est √† ce jour un des langages les plus utilis√© par les developpeurs informatiques.<br/><img src="img/popularityjs.png" style="border:none"/></img><br/>
:::

::: {.column width="49%"}
Il y a √† ce jour plus de 2 millions de packages disponibles sur **npm**<br/><img src="img/npm1.png" style="border:none"/></img>
:::
:::

## Un langage souvent d√©cri√© üëé

JavaScript a souvent mauvaise r√©putation chez les d√©veloppeurs. Et pour cause :

### Des absurdit√©s logiques

Null est un objet ü§î

```{ojs}
typeof null
```

Not a Number est un nombre üôÉ

```{ojs}
typeof NaN
```

Cf [smashingmagazine.com/2011/05/10-oddities-and-secrets-about-javascript](https://www.smashingmagazine.com/2011/05/10-oddities-and-secrets-about-javascript)

### Il est faiblement typ√©

On peut donc d√©finir une variable et changer son type. Attention danger.

```{ojs}
{
let a = "bonjour"
a = 10
return a
}
```

2 variables de 2 types diff√©rents peuvent √™tre consid√©r√©s comme √©gaux.

```{ojs}
{
let a = "40"
let b = 40
return a == b
}
```

Et √ßa peut √™tre source de confusion et de bugs

```{ojs}
{
let someVar = 0
return someVar == false
}
```

Heureusement, il y a le triple √©gal

```{ojs}
{
let someVar = 0
return someVar === false
}
```

### Il n'a pas √©t√© con√ßu pour l'analyse de donn√©es

Par exemple, l'op√©ration de tri par d√©faut trie les valeurs par ordre alphab√©tique.

```{ojs}
{
let a = [7,1,9,3,10,4,5,6,2,8]
return a.sort()
}
```

## ...mais incontournable et prometeur üëç

**C'est le langage du web :**

-   Il n'y a rien √† installer *"en dur*"\* sur les ordinateurs. Il faut juste un navigateur web.
-   Il tourne partout et s'execute dans votre navigateur web (compilation just in time)
-   L'impl√©mentation de Javascript dans les navigateurs est de plus en plus rapide üöÄ
-   Le langage est aujourd'hui standardis√© (ECMA)
-   Grande communaut√©. Beaucoup de ressources et tutos, conf√©rences sur youtube.
-   Beaucoup de choses d√©j√† d√©velopp√©es : Plus de 2 millions de packages sur npm

**Certes, JavaScript n'a pas √©t√© con√ßu pour faire de l'analyse de donn√©es. Mais :**

-   Le langage peut √™tre √©tendu pour mieux le prendre en charge.
-   De nombreuses librairies permettent d√©j√† de manipuler et repr√©senter les donn√©es (`tidy.js`, `Arquero`...).
-   Les performances s'am√©liorent encore avec WebGPU, qui permet de faire des calculs particuli√®rement efficaces pour l'execution d'algorithmes tres paralleles comme le traitement d'image, le machine learning et le rendu 3D.

![](img/webgpu.png){height="80"}

-   Avec WebAssembly, il est d√©sormais possible d'incorporer des briques d√©velopp√©es dans d'autres langages (C, rust, go...) √† l'interieur des biblioth√®ques JavaScript.

![](img/jswasm.png){height="70"}

Du coup, certains pensent que le JavaScript est le langage de demain pour traiter et analyser des donn√©es.

![](img/towards.png)

*https://towardsdatascience.com/javascript-for-data-analysis-2e8e7dbf63a7*

# Observable Javascript üìä

::: notes
Observable Javascript est une √©volution du langage JavaScript pour en faire un langage d√©dui√© √† l'analyse et la visualisation de donn√©es.
:::

Un langage d√©di√© √† la visualisation de donn√©es pour le web

## Observable, kezako ?

L'<b>Observable javascript (ojs)</b> est un ensemble d'am√©liorations apport√©es √† vanilla JavaScript cr√©√© par Mike Bostock (√©galement auteur de D3). Observable JS se distingue par son ex√©cution r√©active, qui convient particuli√®rement bien √† l'exploration et √† l'analyse interactives des donn√©es. Objectif : faire collaborer une communaut√© autour de la visualisation de donn√©es.

![](img/chronologie.png)

<b>Observable</b> est aussi une startup fond√©e par Mike Bostock et Melody Meckfessel, qui propose une plateforme 100% en ligne pour concevoir, partager et diffuser des visualisations de donn√©es.

![](img/observable.png){height="200"}

C'est aussi une <b>plateforme web disponilble √† l'adresse **https://observablehq.com/** qui h√©berge des *notebooks*</b> *computationnels* sur la visualisation de donn√©es. Les notebooks sont comme des billets de blog. Ils contiennent du texte, des images et du contenu multim√©dia. Ils peuvent √™tre rang√©s dans des collections. Ils sont disponibles en ligne via une url. Comme on peut s'y attendre, ils contiennent aussi des lignes de code. L'objectif : faire de la Programmation lettr√©e (<b>literate programming</b>).

![](img/obs.png)

<b>R√©f√©rences</b>

Reactive, reproducible, collaborative: computational notebooks evolve, par Jeffrey M. Perkel. <https://www.nature.com/articles/d41586-021-01174-w>

Javascript for data Analysis, par Mike Bostock <https://towardsdatascience.com/javascript-for-data-analysis-2e8e7dbf63a7>

## JavaScript ‚â† ojs

::: columns
::: {.column width="49%"}
OJS c'est du JavaScript + plein de biblioth√®ques pr√© charg√©es : <br/>

| Symbol   | Name              | Version            |
|----------|-------------------|--------------------|
| \_       | Lodash            | 4.17.21            |
| aq       | Arquero           | \${aq.version}     |
| Arrow    | Apache Arrow      | 4.0.1              |
| d3       | D3.js             | \${d3.version}     |
| dot      | Graphviz          | 0.2.1              |
| htl      | Hypertext Literal | \${htl.version}    |
| Inputs   | Observable Inputs | \${Inputs.version} |
| L        | Leaflet           | \${L.version}      |
| mermaid  | Mermaid           | 9.1.6              |
| Plot     | Observable Plot   | \${Plot.version}   |
| SQLite   | SQL.js            | 1.7.0              |
| topojson | TopoJSON Client   | 3.1.0              |
| vl       | Vega, Vega-Lite   | 5.22.1, 5.2.0      |
:::

::: {.column width="49%"}
OJS c'est aussi une √©volution du langage javascript pour en faire un langage adapt√© √† l'analyse et la visualisation de donn√©es sur le web.

![](img/datascience.png)
:::
:::

## Observable dans Observable

Pour utiliser Observable, on peut donc cr√©er un compte avec une adresse email. Ca permet :

-   coder dans son navigateur web
-   d'h√©berger son code et ses textes
-   partager son travail
-   sauvegarder, versionner, archiver
-   voir ce que font les autres, faire de la veille
-   suivre les compte de son choix (comme sur une r√©seau social)
-   √©changer avec la <ins>communaut√©</ins> (commentaires, forum, ...)
-   travailler √† plusieurs sur un m√™me document
-   se connecter √† des bases de donn√©es ou des fichiers dans le cloud (google sheet)
-   travailler sans rien avoir √† installer sur son ordinateur
-   concevoir des visualisations et les embarquer facilement dans des sites web.

Il faut bien sur avoir une bonne connexion internet

![](img/observable2.png)

Mais, Observable n'est pas completement gratuit.

Les comptes gratuits permettent de tout faire, mais obligent √† travailler de fa√ßon publique. Tout ce qu'on √©crit est directement visible en ligne. Pour travailler de fa√ßon priv√©e, il faut souscrire √† un compte pro üòü

![](img/princing.png)

Heureusement, les comptes pro sont gratuits pour l'enseignement sup√©rieur et la recherche. Tout universitaire peut donc cr√©er un compte et l'utiliser pour sa recherche ou l'enseignement üî¨

![](img/observable_teach.png)

‚ö†Ô∏è Attention, Observablehq est une soci√©t√© priv√©e. Ils peuvent donc changer ces conditions ‚ö†Ô∏è

## Observable dans Quarto

Si on ne souhaite pas cr√©er de compte sur observablehq, il est possible de faire du Observable sans Observable, en travaillant avec le logiciel Quarto. En effet, <ins>**le runtime d'Observable est Open Source**</ins> et peut donc √™tre utilis√© dans d'autres contextes et dans d'autres logiciels. Cela permet aussi de travailler en local sur son ordinateur sans connexion internet.

**Qu'est ce que Quarto¬Æ ?**

Quarto¬Æ est un syst√®me de publication scientifique et technique √† code source ouvert bas√© sur Pandoc.

![](img/quarto.png){height="50"}

Quarto permet de cr√©er des documents markdown, des articles, des rapports, des pr√©sentations, des sites web, des blogs et des livres, aux formats HTML, PDF, Word, ePub, etc.

Il permet de cr√©er un contenu dynamique dans diff√©rents langages : Python, R, Julia et **Observable JavaScript**.

Cela permet de cr√©er des documents, des rapports et des analyses enti√®rement reproductibles

![](img/quartoojs.png)

## Les cellules / chunk {ojs}

Dans Quarto, on peut √©crire/executer du code Observable en utilisant des chuncks **{ojs}**.

Chaque ligne d√©finit une variable et une cellule qui doit √™tre unique.

cellule 1 :

```{ojs}
a = 5 
```

cellule 2 :

```{ojs}
b = 7 
```

cellule 3 :

```{ojs}
a + b
```

Avec ojs, l'ordre d'√©criture n'a pas d'importance ü§î On peut donc √©crire :

Ceci :

```{ojs}
c * d 
```

Avant √ßa

```{ojs}
c = 3
```

et √ßa

```{ojs}
d = 8
```

La raison est que la relation entgre les cellules s'effectue de mani√®re topologique.

![](img/topo.png){height="400"}

Chaque cellule doit imp√©rativement √™tre unique. En cons√©quance, je n'ai pas le droit de red√©finir une de ces variables.

```{ojs}
e = 10
e = 5
```

Il est donc souvent utile de cr√©er des blocs de code avec des {...} quand le traitement devient plus complexe.

```{ojs}
{
  let val1 = 8;
  let val2 = 7;
  val1 = 5;
  return val1 * val2;
}

```

Mais la plupart du temps, pour faire ce genre de calcul, on √©crira plut√¥t des fonctions. Comme ceci :

```{ojs}
function sum(a, b) {
  return a + b;
}
// Appel de la fonction
sum(10, 30)
```

Ou comme cela :

```{ojs}
multi = (a, b) => a * b
// Appel de la fonction
multi(3, 8)
```

Ce parti pris fort, peut √™tre d√©routant. Mais il a un gros avantage. Il permet d'organiser un document ind√©pendemment de la fa√ßon dont on code. Cela permet par exemple de mettre une carte en haut de la page et en annexe technique tout en bas le code qui la g√©n√®re.

## D3.js

L'OJS a √©t√© cr√©√© par Mike Bostock, qui est aussi le developpeur de la biblioth√®que **D3.js** (ou D3). D3 a √©t√© dircetement int√©gr√©e √† l'Observable JavaScript.

![](img/logo-D3.png){height="200"}

D3.js est une biblioth√®que graphique JavaScript d√©velopp√©e par Mike Bostock qui permet l'affichage de donn√©es num√©riques sous une forme graphique et dynamique.

![](img/d3gallery.png)

-   D3 est populaire (200 millions de t√©l√©chargements et 100 000 ‚≠ê sur Github)
-   D3 est flexible (approche bas niveau qui permet de tout faire)
-   D3 est r√©put√© pour ses animations et ses interactions.

**Cette puissance a bien s√ªr un co√ªt. Il y a beaucoup √† apprendre : D3 compte plus de trente modules et un millier de m√©thodes.**

![](img/d3github.png)

Mais c'est le langage de base pour faire de la visualisation de donn√©es pour le web.

```{ojs}
myarray = [7,1,9,3,10,4,5,6,2,8]
```

**d3.array** permet de manipuler les donn√©es. On peut par exemple remplacer notre exemple de tout √† l'heure

```{ojs}
myarray.sort()
```

par :

```{ojs}
d3.sort(myarray)
```

Bien d'autres op√©rations sont possibles

```{ojs}
d3.min(myarray)
d3.max(myarray)
d3.mean(myarray)
d3.median(myarray)
d3.variance(myarray)
d3.deviation(myarray)
d3.cumsum(myarray)
```

Mais d3, c'est surtout un framework de d√©veloppement pour dessiner des visualisations √† partir de donn√©es. C'est aujourd'hui un standard dans le domaine que tout le monde utilise.

D3 est aussi √† la base de nombreuses biblioth√®ques JavaScript, comme les librairie `Plot` et `bertin` que nous allons voir.

## Dessiner pour le web

### La structure d'une page html

Une page html s'organise sous la forme de contenus plac√©s √† l'int√©rieur de balises.

``` html
<html>
  <head>
    <!-- En t√™te de la page -->
    <title>Titre de la carte</title>
  </head>
  <body>
    <!-- Contenu de la page -->
    <h1>Hello World!</h1>
  </body>
</html>
```

A l'int√©rieur de la balise body, on peut dessiner directement des images raster et vecteur.

### Raster vs Vecteur

Il existe deux principaux moyens pour dessiner des √©l√©ments dans une page web : **SVG** & **CANVAS**.

Un raster, c'est une image compos√©e de pixels. Un grille organis√©e en lignes et colonnes. Chaque cellule est un pixel unique. Une image raster a une r√©solution.

Une image vecteur n'a pas de r√©solution. Elle est compos√©e de compos√©e de n≈ìuds (des points dans l'espace) et des formules math√©matiques pour calculer les arcs (des lignes) qui relient ces n≈ìuds entre eux et qui forment ainsi une g√©om√©trie. On distingue trois grands types de g√©om√©tries : point, ligne et polygone.

![](img/vecteurraster.png){\_}

### Canvas

L'√©l√©ment **canvas** est un composant du langage Web HTML qui permet d'effectuer des rendus dynamiques d'images bitmap (raster).

Ce code

``` html
<canvas id="myCanvas2" width="100" height ="100" style="border:1px
solid #000000; background-color: steelblue;"></canvas>
```

donne ceci :

<canvas id="myCanvas2" width="100" height="100" style="border:1px solid #000000; background-color: steelblue;">

</canvas>

### SVG

Le format SVG (Scalable Vector Graphics) est un format de donn√©es con√ßu pour d√©crire des ensembles de graphiques vectoriels. C'est le format qu'on utilise dans le logiciel **Inkscape**.

Ce code

``` html
<svg viewBox="0 0 1000 100" xmlns="http://www.w3.org/2000/svg">
  <rect x="0" y="0" width="100px" height="100px" fill="#F2CD3B" stroke="#06000C" />
</svg>
```

donne ceci :

<svg viewBox="0 0 1000 100" xmlns="http://www.w3.org/2000/svg">

<rect x="0" y="0" width="100px" height="100px" fill="#F2CD3B" stroke="#06000C" />

</svg>

## Dessiner avec D3.js (le DOM)

Avec D3, il est possible de dessiner en JavaScript des images vectorielles au format CANVAS et SVG en manipulant le DOM.

*Le Document Object Model (DOM) est une interface de programmation normalis√©e par le W3C, qui permet √† des scripts d'examiner et de modifier le contenu du navigateur web. Par le DOM, la composition d'une page web est repr√©sent√©e sous forme d'un arbre avec des objets dedans.*

![](img/DOM.png)

Le but c'est d'√©crire par la programmation des instructions qui vont produire le dessin plut√¥t que d'√©crire directement *en dur* le dessin.

### Dessinons du SVG avec D3.js

Cr√©ons un document svg, de 500 pixels de large, 60 pixels de haut et avec du gris en couleur de fond.

```{ojs}
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 500, 60])
    .style("background-color", "#CCC");
    
  return svg.node();
}    
```

On ajoute un cercle rouge avec `svg.append("circle")`

```{ojs}
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 500, 60])
    .style("background-color", "#CCC");
    
  svg
    .append("circle")
    .attr("cx", 50)
    .attr("cy", 30)
    .attr("r", 25)
    .style("fill", "#e04a28");
    
  return svg.node();
}    
```

Attention, les coordonn√©es \[0,0\] sont en haut √† gauche.

![](img/canvas.png) <br/>On dessine un carr√© rouge avec `svg.append("rect")`

```{ojs}
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 500, 60])
    .style("background-color", "#CCC");
    
  svg
    .append("rect")
    .attr("x", 100)
    .attr("y", 5)
    .attr("height", 50)
    .attr("width", 50)
    .style("fill", "#5277bf");
    
  return svg.node();
}    
```

On dessine une ligne avec `svg.append("line")`

```{ojs}
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 500, 60])
    .style("background-color", "#CCC");
    
  svg
    .append("line")
    .attr("x1", 10)
    .attr("y1", 50)
    .attr("x2", 490)
    .attr("y2", 10)
    .style("stroke", "#5277bf");
    
  return svg.node();
}    
```

On √©crit du texte avec `svg.append("text")`

```{ojs}
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 500, 60])
    .style("background-color", "#CCC");
    
    svg
    .append("text")
    .attr("x", 150)
    .attr("y", 30)
    .attr("text-anchor", "middle")
    .attr("alignment-baseline", "middle")
    .attr("font-size", 20)
    .text("This is a text")
    

  return svg.node();
}    
```

On peut m√™me faire des choses plus compliqu√©es

```{ojs}
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 900, 300])
    .style("width", 900)
    .style("height", 300)
    .style("background-color", "white");

  svg
    .append("path")
    .attr("id", "MyPath")
    .attr(
      "d",
      "M 63.076304,216.52334 C 106.76999,160.0853 184.40984,142.61427 252.12247,155.01632 c 99.64554,14.70621 189.6073,65.26698 288.91023,81.72698 85.56711,17.5306 180.8469,21.86234 258.93554,-23.57809 C 832.7795,182.25763 827.06329,125.86632 794.25369,97.048457 749.49459,54.888253 680.9657,40.400439 622.07801,56.259559 578.03603,66.8154 539.24683,112.13225 552.52931,158.88503 c 11.25647,40.10204 58.40308,53.33813 95.48846,51.23085 25.59819,-1.89352 59.88192,-16.69692 56.86407,-47.47388 -3.50716,-31.7693 -26.27339,-57.34863 -59.6113,-41.94273"
    )
    .attr("fill", "none")
    .attr("stroke", "#5277bf");

  svg
    .append("text")
    .append("textPath")
    .attr("href", "#MyPath")
    .attr("dominant-baseline", "baseline")
    .attr("font-size", `48px`)
    .text(
      "Et maintenant, voici un texte qui suit une ligne. C'est trop cool, non ?"
    );

  return svg.node();
}
```

## Dessiner des donn√©es avec D3.js

On cr√©e des donn√©es fictives

```{ojs}
myData = [10, 30, 2, 20, 10]
```

On veut cr√©er des cercles. cr√©e une fonction pour calculer le rayon.

```{ojs}
valmax = d3.max(myData)
radius = d3.scaleSqrt([0, valmax], [0, 35]);
```

Puis, on dessine un SVG.

```{ojs}
{
  const width = 500;
  const height = 75;
  
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, width, height])

  svg
    .append("g")
    .attr("fill", "#e04a28")
    .selectAll("circle")
    .data(myData)
    .join("circle")
    .attr("cx", (d, i) => 50 + i * 100)
    .attr("cy", height / 2)
    .attr("r", (d) => radius(d));

  return svg.node();
}
```

Il est aussi possible de beaucoup d'autres choses graces aux m√©thodes propos√©es par d3.

La fonction `d3.pie()` transforme les donn√©es en un objet contenant des informations pour dessiner des quartiers.

```{ojs}
pie = d3.pie().padAngle(0.1)
pie(myData)
```

La fonction `d3.arc()` permet de dessiner ces quartiers.

```{ojs}
arc = d3.arc().innerRadius(45).outerRadius(220)
```

Ainsi, on a :

```{ojs}
{
  const height = 500;
  const svg = d3
    .create("svg")
    .attr("viewBox", [-width / 2, -height / 2, width, height]);

  svg
    .append("g")
    .attr("fill", "#e04a28")
    .attr("stroke", "#000")
    .attr("stroke-width", "1.5px")
    .attr("stroke-linejoin", "round")
    .selectAll("path")
    .data(pie(myData))
    .join("path")
    .attr("d", arc.cornerRadius(3));

  return svg.node();
}
```

## Animer avec D3.js

```{ojs}
//| echo: false
viewof anim = Inputs.button("OK", { label: "Lancer l'animation" })
```

```{ojs}
//| echo: false
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 500, 60])
    .style("background-color", "#CCC");

  let moncercle = svg
    .append("circle")
    .attr("cx", 50)
    .attr("cy", 30)
    .attr("r", 25)
    .attr("fill", "#e04a28");

  if (anim) {
    moncercle
      .transition()
      .duration(2000)
      .attr("cx", 450)
      .transition()
      .delay(2000)
      .duration(3000)
      .attr("cx", 50)
      .attr("r", 10)
      .attr("fill", "blue")
      .transition()
      .attr("r", 25)
      .attr("fill", "#e04a28");
  }

  return svg.node();
}
```

```{ojs}
//| eval: false
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 500, 60])
    .style("background-color", "#CCC");

  let moncercle = svg
    .append("circle")
    .attr("cx", 50)
    .attr("cy", 30)
    .attr("r", 25)
    .attr("fill", "#e04a28");

  if (anim) {
    moncercle
      .transition()
      .duration(2000)
      .attr("cx", 450)
      .transition()
      .delay(2000)
      .duration(3000)
      .attr("cx", 50)
      .attr("r", 10)
      .attr("fill", "blue")
      .transition()
      .attr("r", 25)
      .attr("fill", "#e04a28");
  }

  return svg.node();
}
```

## Les Inputs

Dans Observable, on a √† disposition des *Inputs* directement pr√™ts √† l'emploi.

### üëâ button

```{ojs}
viewof clicks = Inputs.button("Click")
clicks
```

### üëâ toogle

```{ojs}
viewof mute = Inputs.toggle({label: "Mute", value: true})
mute
```

### üëâ range

```{ojs}
viewof gain = Inputs.range([0, 11], {value: 5, step: 0.1, label: "Gain"})
gain
```

### üëâ checkbox

```{ojs}
viewof colors = Inputs.checkbox(["red", "green", "blue"], {label: "color"})
colors
```

### üëâ radio

```{ojs}
viewof color = Inputs.radio(["red", "green", "blue"], {label: "color"})
color
```

### üëâ select

```{ojs}
villes = ["Cotonou", "Porto-Novo", "Ouidah"]
viewof maville = Inputs.select(villes, {value: "steelblue", label: "Favorite color"})
maville
```

### üëâ text

```{ojs}
viewof text = Inputs.text()
text
```

### üëâ textarea

```{ojs}
viewof textarea = Inputs.textarea()
textarea
```

### üëâ date

```{ojs}
viewof date = Inputs.date()
date
```

### üëâ color

```{ojs}
viewof pickcolor = Inputs.color({label: "couleur pr√©f√©r√©e", value: "#4682b4"})
pickcolor
```

### üëâ file

```{ojs}
viewof file = Inputs.file()
file
```

### üëâ formulaire

```{ojs}
//| panel: sidebar
//| echo: false
viewof range1 = Inputs.range([0, 11], {value: 5, step: 0.1, label: "range1"})
viewof range2 = Inputs.range([0, 11], {value: 5, step: 0.1, label: "range2"})
viewof range3 = Inputs.range([0, 11], {value: 5, step: 0.1, label: "range3"})
```

```{ojs}
//| panel: fill
range1
range2
range3

```

## Tout est r√©actif üî•

Dans Observable, grace √† la relation topologique entre les cellules, tout est r√©actif. Chaque fois qu'on bouge quelque chose, ce qui en d√©pend est r√©√©x√©cut√©.

```{ojs}
viewof age = Inputs.range([15, 70], {label: "age", value: 30, step: 1,})
viewof nom = Inputs.text({label: "nom", value: "Nicolas"})
```

Par exemple :

```{ojs}
md`Je m'appelle **${nom}** et j'ai **${age}** ans :-)`
```

Reprenons notre SVG de tout √† l'heure

```{ojs}
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 500, 60])
    .style("background-color", "#CCC");
    
  svg
    .append("circle")
    .attr("cx", 50)
    .attr("cy", 30)
    .attr("r", 25)
    .style("fill", "#e04a28");
    
  return svg.node();
}
```

On peut facilement proposer √† l'utilisateur de moidifier ce dessin en rempla√ßant des valeurs par des variables pilot√©es par des inputs.

```{ojs}
//| echo: true
//| eval: false
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 500, 60])
    .style("background-color", "#CCC");
    
  svg
    .append("circle")
    .attr("cx", cx)
    .attr("cy", 30)
    .attr("r", r)
    .style("fill", col);
    
  return svg.node();
}
```

Par exemple :

```{ojs}
//| panel: input
//| echo: false
viewof cx = Inputs.range([30, 470], {value: 50, step: 1, label: "position"})
viewof col = Inputs.color({ value: "#e04a28", label: "couleur"})
viewof r = Inputs.range([5, 30], {value: 25, step: 0.1, label: "rayon"})

```

```{ojs}
//| echo: false
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 500, 60])
    .style("background-color", "#CCC");
    
  svg
    .append("circle")
    .attr("cx", cx)
    .attr("cy", 30)
    .attr("r", r)
    .style("fill", col);
    
  return svg.node();
}
```

## Les donn√©es

L'ajout de donn√©es s'effectue avec l'instruction `FileAttachment()`

### üëâ fichier csv

```{ojs}
data1 = FileAttachment("data/afrika_data.csv").csv()
```

Les donn√©es sont import√©es et converties automatiquement au format json

```{ojs}
//| echo: false
data1
```

Pour les visualiser, on utilise `Inputs.table()`

```{ojs}
Inputs.table(data1)
```

### üëâ fichier xlsx

On peut √©galement importer des fichiers excel

```{ojs}
classeur = FileAttachment("data/afrika.xlsx").xlsx()
```

On obtient la liste des feuilles comme cela :

```{ojs}
classeur.sheetNames
```

Puis, on peut choisir la feuille √† ouvrir

```{ojs}
data2 = classeur.sheet("data", {
  headers: true
})
```

```{ojs}
//| echo: false
data2
```

### üëâ Mise en forme des donn√©es

Pour mettre en forme les donn√©es, on peut le faire en pure JavaScript.

```{ojs}
subdata1 = data1
  .filter((d) => +d.ESPVIE > 65)
  .map((d) => ({ code: d.iso3, nom: d.nom, POP: d.POP, PIB: d.PIB, ESPVIE: d.ESPVIE }))
  .sort((a, b) => d3.descending(b.ESPVIE, a.ESPVIE))
```

Ca donne ceci :

```{ojs}
//| echo: false
Inputs.table(subdata1)
```

On peut aussi utiliser `arquero`. Voir : [https://observablehq.com/\@observablehq/data-wrangler](@observablehq/data-wrangler).

```{ojs}
subdata2 = aq
  .from(data1)
  .filter((d) => d["ESPVIE"] > 65)
  .rename({ iso3: "code" })
  .select("code", "nom", "POP", "PIB", "ESPVIE")
  .orderby("ESPVIE")
  .objects()
```

Le r√©sultat est le m√™me.

```{ojs}
//| echo: false
Inputs.table(subdata2)
```

### üëâ fichier geoJSON

Pour utiliser des g√©om√©tries, on utilisera prioritairement le format geoJSON.

```{ojs}
basemap = FileAttachment("data/africa.json").json()
```

Voil√† la structure d'un geoJSON

```{ojs}
//| echo: false
basemap
```

Et voici √† quoi il ressemble si on l'affiche (nous verrons plus tard comment...)

```{ojs}
//| eval: true
//| echo: false
bertin.quickdraw(basemap, 500)
```

## Faire une carte avec D3.js

La fonction `d3.geoPath()` du module `d3.geo` permet de convertir un fond de carte en dessin svg. Cette fonction prend comme param√®tre des fonctions de projections telles que d√©finies dans les modules `d3.geo` & `d3.geoprojection`.

On importe des donn√©es

```{ojs}
monde = FileAttachment("data/world.json").json()
```

On d√©finit une fonction de projection

```{ojs}
myproj = d3.geoNaturalEarth1()
```

On cr√©e une fonction `path` qui permet de convertir des coordonn√©es lat/lon en un chemin SVG dans une projection donn√©e.

```{ojs}
path = d3.geoPath(myproj)
```

Puis, on dessine la carte

On cr√©e un document SVG

``` js
const svg = d3
  .create("svg")
  .attr("viewBox", [0, 0, 1000, 500])
  .style("width", "100%")
  .style("height", "auto");
```

On ajoute une premi√®re couche (calque g) au SVG : Un polygone qui correspond √† l'espace terrestre dans la projection donn√©e.

``` js
svg
  .append("g")
  .append("path")
  .datum({ type: "Sphere" })
  .attr("fill", "#a9daeb")
  .attr("d", path);
```

Avec la fonction `d3.geoGraticule10()`, on ajoute des lignes de latitude et loingitude. On les affiche en pointill√©.

``` js
svg
  .append("g")
  .append("path")
  .datum(d3.geoGraticule10())
  .attr("d", path) 
  .style("fill", "none")
  .style("stroke", "white")
  .style("stroke-width", 0.8)
  .style("stroke-opacity", 0.5)
  .style("stroke-dasharray", 2);
```

Et enfin, on ajoute les pays de monde.

``` js
svg
  .append("g")
  .append("path")
  .datum(monde)
  .attr("fill", "#508bab")
  .attr("fill-opacity", 0.9)
  .attr("stroke", "white")
  .attr("stroke-width", 0.2)
  .attr("d", path); 
```

Et tout √† la fin, on renvoie le noeud SVG.

``` js
return svg.node();
```

Et voil√† le r√©sultat :

```{ojs}
//| eval: true
//| echo: false
{
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, 1000, 500])
    .style("width", "100%")
    .style("height", "auto");

// La sph√®re
  svg
    .append("g")
    .append("path")
    .datum({ type: "Sphere" })
    .attr("fill", "#a9daeb")
    .attr("d", path); 

  // Les graticules
  svg
    .append("g")
    .append("path")
    .datum(d3.geoGraticule10())
    .attr("d", path) 
    .style("fill", "none")
    .style("stroke", "white")
    .style("stroke-width", 0.8)
    .style("stroke-opacity", 0.5)
    .style("stroke-dasharray", 2);

  // DATUM
  svg
    .append("g")
    .append("path")
    .datum(monde)
    .attr("fill", "#508bab")
    .attr("fill-opacity", 0.9)
    .attr("stroke", "white")
    .attr("stroke-width", 0.2)
    .attr("d", path); 

  return svg.node();
}
```

## Interop√©rabilit√© R et OJS

Dans `Quarto`, il est possible de combiner du code en R et du code en OJS.

Pour cela, on utilise la fonction `ojs_define()`

### Une simple variable

-   **chunks {r}**

On d√©finit la variable `myvar`

```{r}
myvar = 12
```

Puis, avec l'instruction ojs_define, on rend cette variable accessible en javascript.

```{r}
ojs_define(myvar)
```

-   **chunks {ojs}**

Et maintenant, `myvar` existe dans ojs.

```{r}
myvar
```

### Un dataframe

-   **chunks {r}**

Dans R, On charge un dataframe avec \`read.csv()\`\`

```{r}
data <- read.csv("data/afrika_data.csv")
```

Comme pr√©c√©demment, nous utilisons `ojs_define` pour rendre cette variable accessible dans Observable. Nous renommons cette variable en newdata.

```{r}
ojs_define(newdata = data)
```

-   **chunks {ojs}**

C√¥t√© ojs, les donn√©es sont disponibles. Elles ont √©t√© converties au format json. Mais elles ne sont pas tout √† fait au format attendu.

```{ojs}
newdata
```

La fonction transpose permet de les convertir au bon format.

```{ojs}
Inputs.table(transpose(newdata))
```

### Un Spatial dataframe

-   **chunks {r}**

Ici, on ouvre un fichier au format gpkg.

```{r}
library("sf")
countries <- st_read("data/countries.gpkg", quiet = T)
```

Puis, √† l'aide de la librarie `geojsonsf`, on le convertit au format geojson avant d'utiliser `ojs_define`

```{r}
library("geojsonsf")
ojs_define(countries = sf_geojson(countries))
```

-   **chunks {ojs}**

Notez qu'avec ojs_define, nous avons pass√© la variable geo comme une cha√Æne et non comme un objet.

```{ojs}
countries.substr(1, 300)
```

Nous utilisons l'instruction javascript `JSON.parse` pour refabriquer un geojson valide.

```{ojs}
countries2 = JSON.parse(countries) 
countries2
```

On a bien un beau geoJSON qu'on peut afficher

```{ojs}
//| eval: true
//| echo: false
bertin.quickdraw(countries2)
```

## Librairies externes

Observable javascript n'est pas un √©cosyst√®me ferm√©. Des millions de librairies javascript existent sur NPM (√©quivalent du CRAN pour R). Il est possible de les utiliser.

![](img/npm.png)<br/>

Ici, nous pouvons les importer directement avec l'instruction `require()`

#### La biblioth√®que `geocountries`

Avec `@`, on sp√©cifie la version de la biblioth√®que.

```{ojs}
//| eval : false
geocountries = require("geocountries@latest")
```

Vous pouvez aussi utiliser une biblioth√®que localement en sp√©cifiant le chemin sur votre ordinateur.

```{ojs}
geocountries = require("./lib/geocountries.js")
```

On peut maintenant utiliser la fonction getcode du package `geocountries`

```{ojs}
geocountries.getcode("B√©nin")
```

#### La biblioth√®que `statsbreaks`

Une biblioth√®que pour faire des discr√©tisations

```{ojs}
//| eval : false
discr = require("statsbreaks@latest")
```

ou

```{ojs}
discr = require("./lib/statsbreaks.js")
```

```{ojs}
gdppc = data1.map(d => d.PIB/d.POP)
discr.breaks({ values: gdppc, method: "quantile", nb: 5, precision: 2 })
```

## Imports

On l'a dit tout √† l'heure, Observable c'est aussi une plateforme web hebergeant des notebooks.

![](img/trendings.png)<br/>

Si on a une connexion internet, il ets possible d'importer n'importe quelle cellule de n'importe quel notebook avec la fonction `import`. Dit autrement, toutes les notebooks h√©berg√©s sur observablehq.com fonctionnent comme des api.

```{ojs}
import {SankeyChart} from "@d3/sankey"
import {energy} from "@d3/sankey"
```

Puis, on peut utiliser cette fonction.

```{ojs}
chart = SankeyChart({
  links: energy
}, {
  nodeGroup: d => d.id.split(/\W/)[0], // take first word for color
  width,
  height: 600
})
```

# La biblioth√®que bertin üó∫Ô∏è

Une biblioth√®que JavaScript pour la cartographie th√©matique

::: notes
La biblioth√®que bertin est une bibliotheque de cartographie pour le web. Voir : https://github.com/neocarto/bertin
:::

## Principes

![](img/bannerbertin.png)

[bertin](https://github.com/neocarto/bertin) est une biblioth√®que (un ensemble de fonctionnalit√©s) √©crite en [JavaScript](https://developer.mozilla.org/fr/docs/Web/JavaScript) qui permet de r√©aliser des cartes th√©matiques pour le web. Son d√©veloppement s'appuie en grande partie sur le librairie javascript [d3.js](https://d3js.org/) d√©velopp√©e par Mike Bostock depuis 10 ans. Le d√©veloppement a d√©but√© en novembre 2021. Il y a 8 contributeurs. 240 ‚≠ê sur Github.

![](img/logo_bertin.png)

On charge la biblioth√®que avec l'instruction `require` en indiquant le num√©ro de version ou en prenant la derni√®re version.

```{ojs}
//| eval : false
bertin = require("bertin@1.6.5")
```

Si on souhaite travailler sans connexion internet, il est possible de t√©l√©charger la bibliotheque dans un dossier, puis d'indiquer le lien vers ce dossier.

Lien de t√©l√©chargement : [https://cdn.jsdelivr.net/npm/bertin\@latest](https://cdn.jsdelivr.net/npm/bertin@latest)

Puis

```{ojs}
bertin = require("./lib/bertin.js")
```

Le principe de la biblioth√®que bertin est de proposer un outil permettant de r√©aliser rapidement des cartes th√©matiques vari√©es sans faire appel √† la programmation en JavaScript ni directement √† la biblioth√®que D3.js. ![](img/level.png)

Elle permet de r√©aliser de nombreux types de cartes th√©matiques.

![](img/gallery.png)

## Pr√©paration des donn√©es

Voyons ici le d√©but du processus de cr√©ation cartographique.

### Import

Import des donn√©es sur les pays du monde

Les g√©om√©tries

```{ojs}
world = FileAttachment("data/world.json").json()
```

```{ojs}
//| echo: false
world
```

Les donn√©es attributaires

```{ojs}
stats = FileAttachment("data/worldbank_data.csv").csv()
```

On regarde les donn√©es

```{ojs}
Inputs.table(stats)
```

On ne garde que l'ann√©es 2019

```{ojs}
stats2019 = stats.filter(d => d.date == 2019)
```

Et on affiche le r√©sultat

```{ojs}
Inputs.table(stats2019)
```

### Jointure

On r√©alise une jointure gr√¢ce aux fonctionnalit√©s `match` et `merge` disponibles dans `bertin`.

```{ojs}
bertin.match(world, "id", stats2019, "iso3c")
```

Le niveau de compatibilit√© est bon. On r√©alise la jointure et on cr√©e le nouveau jeu de donn√©es `world2019`

```{ojs}
world2019 = bertin.merge(world, "id", stats2019, "iso3c")
```

### quickdraw

La fonction `quickdraw` permet de visualiser la carte.

```{ojs}
bertin.quickdraw(world2019)
```

### properties.table

La fonction `properties.table` permet de r√©cup√©rer la table attributaire.

```{ojs}
Inputs.table(bertin.properties.table(world2019))
```

## Syntaxe

Avec `bertin`, on utilise la fonction `draw()` pour dessiner tous les types de cartes. La fonction prend en entr√©e un objet JavaScript contenant toutes les informations n√©c√©ssaires.

![](img/bertin_code.png)

L'ordre des couches d√©finit l'ordre d'affichage. Ce qui est √©crit au dessus s'affiche au dessus.

## Carte simple

La fonction `draw` permet de dessiner n'importe quel type de carte.

La syntaxe minimale est la suivante :

*NB : Le type "simple" est facultatif car c'est le type par d√©faut.*

```{ojs}
bertin.draw({ layers: [ {geojson: world2019} ] })
```

## D√©finir les styles

Le rendu peut √™tre tr√®s largement param√©tr√©. Les styles (couleurs, transparence, √©paisseur, etc) reprennent les noms des attributs SVG.

```{ojs}
bertin.draw({ 
  layers: [
    { 
      geojson: world2019,
      fill: "#F6836F",
      fillOpacity: 0.8, 
      stroke:"#F25842",
      strokeWidth: 2,
      strokeDasharray: [3,5] 
    }
  ]
})
```

## G√©n√©ralisation

En cartographie th√©matique, il est souvent utile de g√©n√©raliser (simplifier) un fond de carte. Cela permet d'**am√©liorer la lecture** et de **r√©duire le poids** le fond de carte √† afficher, ce qui est tr√®s important en cartographie sur le web. Une fa√ßon de faire cela est d'utiliser la biblioth√®que `geotoolbox`

On charge la biblioth√®que avec l'instruction `require`

```{ojs}
//| eval : false
geo = require("geotoolbox@latest")
```

*(Pour travailler sans connexion, on peut aussi la t√©l√©charger ici : [https://cdn.jsdelivr.net/npm/geotoolbox\@latest](https://cdn.jsdelivr.net/npm/geotoolbox@latest))*

```{ojs}
geo = require("./lib/geotoolbox.js")
```

Puis, on utilise la fonction `simplify()`

```{ojs}
//| echo: true
//| eval: false
geo.simplify(world2019, {k: 0.1})
```

```{ojs}
//| echo: false
//| eval: true
world02 = geo.simplify(world2019, {k: 0.02})
```

Si on met la valeur de k dans un slider, on a alors une g√©n√©ralisation inteactive.

```{ojs}
//| echo: false
//| eval: true
viewof simpl = Inputs.range([0.0025, 0.1], {value: 0.05})
world2019_simpl = geo.simplify(world2019, {k: simpl})
bertin.draw({ layers: [ { geojson: world2019_simpl, fill: "#F25842" }]})
```

Notez que la biblioth√®que `geotoolbox` vous permet de faire la plupart des op√©rations SIG utiles en cartographie th√©matique (extractions des contours, agr√©gations, g√©n√©ralisation, centroides, etc.)

![](img/geotoolbox.png){\_}

### Exemple de traitement avec `geotoolbox`

On charge le fond de carte de l'Afrique

```{ojs}
afr = FileAttachment("data/africa.json").json()
```

On selectionne le B√©nin et on construit un buffer autour du pays. La distance est g√©r√©e par un slider. On intersecte les pays avec le buffer. Le tout en temps r√©el.

On extrait le B√©nin

``` js
ben = geo.filter(afr, d => d.id == "BEN")
```

On calcule un buffer autour du B√©nin

``` js
buff = geo.buffer(ben, { dist: distance })
```

On intersecte les pays d'Afrique avec ce Buffer

``` js
clip = geo.clip(afr, { clip: buff })
```

Puis on affiche les diff√©rentes couches

```{ojs}
//| echo: false
//| eval: true
ben = geo.filter(afr, d => d.id == "BEN")
buff = geo.buffer(ben, { dist: distance })
clip = geo.clip(afr, { clip: buff })
```

```{ojs}
//| echo: false
viewof distance = Inputs.range([50, 2000], { label: "Distance", step: 1, value : 100 })
```

```{ojs}
//| echo: false
mapclip1 = bertin.draw({
  params: {extent: afr, width: 500},
  layers: [
    { type: "header", text: `${distance} km autour du Benin` },
    {
      geojson: ben,
      strokeWidth: 1.1,
      fill: "#F25842"
    },
    {
      geojson: buff,
      strokeWidth: 3,
      stroke: "#F25842",
      fill: "none"
    },
     {
      geojson: clip,
      strokeWidth: 1,
      stroke: "white",
      fill: "#F6836F"
    },
         {
      geojson: afr,
      strokeWidth: 5,
      stroke: "none",
      fill: "#CCC"
    },
  ]
})
```

Ce n'est pas juste de l'affichage. On a effct√© une vraie op√©ration SIG. La couche intersect√©e est bien cr√©√©e comme nouvel objet geoJSON.

```{ojs}
//| echo: false
bertin.draw({
  params: {width: 200},
  layers: [
  {
      geojson: clip,
      strokeWidth: 1.1,
      fill: "#F25842"
    }
  ]
})
```

## Projection

Faire une carte, c'est aussi choisir comment on passe de la sph√®re au plan : d'un monde en 3 dimensions √† une carte en 2 dimensions.

![](img/orange.jpeg)<br/>

Dans `bertin`, les projections se d√©finissent le l'objet *params*.

```{ojs}
//| echo: true
//| eval : false
bertin.draw({ 
  params: {projection: "nom de la projection"},
  layers: []
})
```

De nombreuses projection sont disponibles dans l'√©cosyst√®me de D3.js grace aux modules `d3.geo` et `d3.geoprojection`

```{ojs}
//| echo: false
//| eval : true
prj = ["Polar","Spilhaus","InterruptedSinusoidal", "Armadillo", "Baker", "Gingery", "Berghaus","Loximuthal", "Healpix", "InterruptedMollweideHemispheres", "Miller", "Aitoff"]
viewof projection = Inputs.select(prj)
bertin.draw({ 
  params: {projection: projection, width: 700, clip: true},
  layers: [ 
    { type: "outline", stroke: "#F25842", strokeWidth:2, fill: "none" },
    { geojson: world02, fill: "#F25842" },
    { type: "geolines", stroke: "#F25842", strokeWidth:1, fill: "none" },
  ]
})
```

Mais la librairie `bertin` permet √©galement d'utiliser des projections au format proj4 ou epsg.

```{ojs}
//| echo: true
//| eval: false
robinson = "+proj=robin +lon_0=0 +x_0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
bertin.draw({ 
  params: {projection: robinson},
  layers: []
})
```

```{ojs}
//| echo: false
//| eval : true
robinson = "+proj=robin +lon_0=0 +x_0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
bertin.draw({ 
  params: {projection: robinson, width: 700, clip: true},
  layers: [ 
    { type: "outline", stroke: "#F25842", strokeWidth:2, fill: "none" },
    { geojson: world02, fill: "#F25842" },
    { type: "geolines", stroke: "#F25842", strokeWidth:1, fill: "none" },
  ]
})
```

## Marges et couleur de fond

On peut aussi d√©finir les parametres g√©n√©raux de la carte, comme la taille de la carte, les marges et la couleur de fond.

``` js
{params : {width: 500, margin : [20, 0, 0, 0], background: "grey"} }
```

<br/>

```{ojs}
//| echo: false
//| eval : true
viewof haut = Inputs.range([0, 100], {value: 0, step: 1, label: "haut"})
viewof droite = Inputs.range([0, 100], {value: 0, step: 1, label: "droite"})
viewof bas = Inputs.range([0, 100], {value: 0, step: 1, label: "bas"})
viewof gauche = Inputs.range([0, 100], {value: 0, step: 1, label: "gauche"})
viewof taille = Inputs.range([300, 1000], {value: 500, step: 1, label: "taille"})
viewof colo = Inputs.color({label: "couleur", value: "#cde5fe"})
// La carte
bertin.draw({ 
  params: {width: taille, margin: [haut, droite, bas, gauche], background: colo},
  layers: [
    { geojson: world02, fill: "#F25842" }
  ]
})
```

## Couches d'habillage

Il existe de nombreuses couches d'habillage disponibles dans `bertin`. Elles ont tous des param√®tres par d√©faut.

### Outline

Le type `outline` permet d'afficher l'espace terrestre.

``` js
{type: "outline" }
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ 
  params: {width: 600, projection: "Bertin1953"},
  layers: [
   {type : "outline", stroke: "black", fill:"none", strokeWidth: 1, strokeOpacity: 1},
  ]
})
```

### Graticule

Le type `graticule` permet d'afficher les lignes de latitude et de longitude.

``` js
{type: "graticule", step: [10,20]}
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ 
  params: {width: 600, projection: "Bertin1953"},
  layers: [
   {type : "graticule", stroke: "black", strokeWidth: 1, strokeOpacity: 1},
   {type : "outline", stroke: "none", fill:"none"},
  ]
})
```

### Geolines

Le type `geolines` permet d'afficher l'√©quateur, les tropiques et les cercles polaires

``` js
{type: "geolines"}
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ 
  params: {width: 600, projection: "Bertin1953"},
  layers: [
   {type : "geolines", stroke: "black"},
   {type : "outline", stroke: "none", fill:"none"},
  ]
})
```

### Waterlines

Le type `waterlines` permet d'afficher des lignes autour des terres, comme sur les cartes anciennes

``` js
{type: "waterlines", geojson: world, nb: 5}
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ 
  params: {width: 600, projection: "Bertin1953"},
  layers: [
   {type : "waterlines", geojson: world02, stroke: "black", nb: 5},
   {type : "outline", stroke: "none", fill:"none"},
  ]
})
```

### Rhumbs

le type `rhumbs` cr√©e des pseudo lignes de rhumbs pour reproduire des styles de cartes anciennes (portulans)

``` js
{type: "rhumbs"}
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ 
  params: {width: 600, projection: "Bertin1953"},
  layers: [
   {type : "rhumbs", strokeOpacity: 1, stroke:"black"},
   {type : "outline", stroke: "none", fill:"none"},
  ]
})
```

### Header

Le type `header` permet d'ajouter un titre

``` js
{type: "header", text : "Titre de la carte" }
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ 
  params: {width: 600, projection: "Bertin1953"},
  layers: [
   {type : "header", text : "Titre de la carte"},
   {type : "outline", stroke: "none", fill:"#ddd"},
  ]
})
```

### Footer

Le type `footer` permet d'ajouter la source

``` js
{type: "footer", text : "Banque mondiale, 2019", anchor: "middle" }
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ 
  params: {width: 600, projection: "Bertin1953"},
  layers: [
   {type: "footer", text : "Banque mondiale, 2019", anchor: "middle" },
   {type : "outline", stroke: "none", fill:"#ddd"},
  ]
})
```

### Text

le type `text` parmet d'ajouter du texte n'importe o√π sur la carte

``` js
{type: "text", position : [100,200], text: "Mon texte ici" }
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ 
  params: {width: 600, projection: "Bertin1953"},
  layers: [
   {type: "text", position : [100,200], text: "Mon texte ici" },
   {type : "outline", stroke: "none", fill:"#ddd"},
  ]
})
```

### Label

Le type `label` permet d'afficher du text li√© au fond de carte.

``` js
{type : "label", geojson : africa, values: "id"}
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({
  params: {extent: afr, width: 600},
  layers: [
      {type : "label", geojson : afr, values: "id" }
  ]
})
```

### Shadow

Le type `shadow` permet d'ajouter une ombre sous une couche

``` js
{type: "shadow" }
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ 
  params: {width: 600, projection: "Bertin1953"},
  layers: [
   {geojson: world02, fill: "white" },
   {type : "shadow", geojson: world02},
   {type : "outline", stroke: "none", fill:"none"},
  ]
})
```

### Inner

Le type `inner` permet d'ajouter un effet de d√©grad√© sur les contours. C'est tr√®s utilis√© en cartographie d'√©dition.

``` js
{type: "inner" }
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ 
  params: {width: 600, projection: "Bertin1953"},
  layers: [
   {type : "inner", geojson: world02},
   {geojson: world02, fill: "white" },
   {type : "outline", stroke: "none", fill:"none"},
  ]
})
```

### Hatch

Le type `hatch` permet d'ajouter des hachures sur la carte. Ca rajoute une texture √† la carte. C'est uniquement esth√©tique.

``` js
{type: "Hatch", angle: 45, spacing: 4 }
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ 
  params: {width: 600, projection: "Bertin1953"},
  layers: [
    {type: "hatch", angle: 45, spacing: 4,  stroke: "black", strokeOpacity: 0.4},
   {type : "outline", stroke: "none", fill:"#ddd"},
  ]
})
```

### Tissot

Le type `tissot` permet d'afficher l'indicatrice de Tissot.

``` js
{type: "tissot" }
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ 
  params: {width: 600, projection: "Bertin1953"},
  layers: [
    {type: "tissot", fill:"black", stroke:"none"},
   {type : "outline", stroke: "none", fill:"white"},
  ]
})
```

### scalebar

Le type `scalebar` permet d'afficher l'√©chelle.

``` js
{type: "scalebar" }
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({
  params: {extent: ben, margin: 50, width: 600},
  layers: [
    {
      geojson: ben,
      strokeWidth: 1.5,
      fill: "#BBB"
    },
       {
      geojson: afr,
      strokeWidth: 1,
      fill: "#CCC"
    },
    {type: "scalebar", x: 400}
  ]
})
```

### minimap

Le type `minimap` permet d'afficher une carte de localisation dans n'importe quelle projection.

``` js
{type: "minimap" }
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({
  params: {extent: afr, margin: 100, width: 600},
  layers: [
      {type: "minimap", projection: "Polar"},
     {
      geojson: world02,
      strokeWidth: 1,
      fill: "#CCC"
    }
  ]
})
```

### tiles

Le type `tiles` permet d'afficher des tuiles raster, mais uniquement dans la projection Web Mercator.

``` js
{type: "tiles", style: "worldimagery" }
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({
  params: {extent: afr, margin: 100, width: 600},
  layers: [
      {type: "tiles", style: "worldimagery"}
  ]
})
```

### logo

Le type `logo` vous perlet d'afficher une image sur la carte.

``` js
{type : "logo", url: "http://myimage.png", position: "left"}
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ 
  params: {width: 600, projection: "Bertin1953"},
  layers: [
   {type : "logo"},
   {type : "outline", stroke: "none", fill:"#ddd"},
  ]
})
```

## Symboles proportionnels

Pour r√©pr√©senter des donn√©es quantgitatives absolues, on utilise la variable visuelle **TAILLE**. En pratique, cela revient la plupart du temps √† utiliser des cercles proportionnels. Dans `bertin`, on utilisera alors le type `bubble`.

``` js
{type "bubble", geojson : world, values: "pop"}
```

**üí° En param√©trant l'attribut `tooltip`, on peut survoler les cercle spour avoir une infobulle üí°**

``` js
tooltip: [
  "$country",
  d => Math.round(d.properties.POP/1000000) + " millions de personnes"
]
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ layers: [ 
  {type: "bubble", geojson: world02, values: "POP", fill: "#F25842", leg_x: 80, leg_y: 200,  leg_title: `Nombre
d'habitants`, leg_round:0, tooltip:["$country", d => Math.round(d.properties.POP/1000000) + " millions de personnes"]}, 
  {geojson: world02, fill:"#CCC"}
  ] })
```

On fait varier la taille des cercles avec le param√®tre `k`, qui corrrespond au rayon du plus gros cercle.

``` js
{type "bubble", geojson : world, values: "pop", k: 100}
```

<br/>

```{ojs}
//| echo: false
//| eval: true
viewof k1= Inputs.range([5, 100], {step: 1, value: 50, label: "k"})
bertin.draw({ layers: [ 
  {type: "bubble", geojson: world02, values: "POP", fill: "#F25842", k: k1, leg_x: 80, leg_y: 200,  leg_title: `Nombre
d'habitants`, leg_round:0, tooltip:["$country", d => Math.round(d.properties.POP/1000000) + " millions de personnes"]}, 
  {geojson: world02, fill:"#CCC"}
  ] })
```

Avec l'argument `dorling: true`, on obtient un cartogramme de Dorling.

``` js
{type "bubble", geojson : world, values: "pop", dorling: true}
```

<br/>

```{ojs}
//| echo: false
//| eval: true
viewof k2= Inputs.range([5, 100], {step: 1, value: 50, label: "k"})
viewof d1 = Inputs.toggle({label: "Dorling", value: true})
bertin.draw({ layers: [ 
  {type: "bubble", geojson: world02, values: "POP", fill: "#F25842", k: k2, dorling:d1,leg_x: 80, leg_y: 200,  leg_title: `Nombre
d'habitants`, leg_round:0, tooltip:["$country", d => Math.round(d.properties.POP/1000000) + " millions de personnes"]}, 
  {geojson: world02, fill:"#CCC"}
  ] })
```

## Carr√©s

Des variantes sont possibles. On peut remplacer les cercles par des carr√©s en utilisant le type `squares`

``` js
{type "square", geojson : world, values: "pop"}
```

Avec le param√®tre `demers = true`, on obtient un cartogramme de Demers.

<br/>

```{ojs}
//| echo: false
//| eval: true
viewof k3= Inputs.range([5, 100], {step: 1, value: 50, label: "k"})
viewof d2 = Inputs.toggle({label: "Demers", value: false})
bertin.draw({ layers: [ 
  {type: "square", geojson: world02, values: "POP", fill: "#F25842", k: k3, demers: d2, leg_x: 80, leg_y: 200,  leg_title: `Nombre
d'habitants`, leg_round:0, tooltip:["$country", d => Math.round(d.properties.POP/1000000) + " millions de personnes"]}, 
  {geojson: world02, fill:"#CCC"}
  ] })
```

## *Spikes*

On peut aussi faire varier la hauteur avec le type `spikes`

``` js
{type "spikes", geojson : world, values: "pop"}
```

<br/>

```{ojs}
//| echo: false
//| eval: true
viewof k4= Inputs.range([5, 100], {step: 1, value: 50, label: "k"})
viewof w1 = Inputs.range([5, 100], {step: 1, value: 10, label: "w"})
bertin.draw({ layers: [ 
  {type: "spikes", geojson: world02, values: "POP", stroke: "#F25842",fill: "#F25842",fillOpacity:1,  k: k4, w: w1,
  leg_x: 80, leg_y: 200,  leg_title: `Nombre
d'habitants`, leg_round:0, tooltip:["$country", d => Math.round(d.properties.POP/1000000) + " millions de personnes"]}, 
  {geojson: world02, fill:"#CCC"}
  ] })
```

## Typologies

Pour cartographier des donnes qualitatives nominales, on peut utiliser la variable visuelle COULEUR (teinte). Dans `bertin`, cela revient √† faire varier l'attribut `fill` avec le type `typo` (pour typologie).

``` js
{geojson: world, fill: { type: "typo", values: "regions", colors: "Tableau10" } }
```

<br/>

```{ojs}
//| echo: false
//| eval: true
viewof pal1 = Inputs.select(["Tableau10", "Category10", "Accent", "Dark2", "Paired", "Pastel1", "Pastel2", "Set1", "Set2", "Set3"], {value: "Tableau10", label: "Palette"})
bertin.draw({ layers: [ 
  {geojson: world02, fill: {type: "typo", values: "subregiond", colors: pal1, leg_x: 30, leg_y: 80, leg_h: 11, leg_title: "Regions"}, tooltip:["$country", "$subregiond"] }
  ] })
```

## Cartes choropl√®thes

Pour r√©aliser une carte choropl√®the, on utilise le type `choro` sur le param√®tre `fill`.

``` js
{geojson: world, fill: { type: "choro", values: "gdppc", colors: "BuPu" } }
```

On peut choisir une palette de couleurs.

```{ojs}
//| echo: false
//| eval: true
viewof pal2 = Inputs.select(["BuGn", "BuPu", "GnBu", "OrRd", "PuBuGn", "PuBu", "PuRd", "RdPu", "YlGnBu", "YlGn", "YlOrBr", "YlOrRd"], {value: "BuPu", label: "Palette"})
```

On peut aussi faire varier le nombre de classes (`nbreaks`) et la m√©thode de discr√©tisation (`method`)

```{ojs}
//| echo: false
//| eval: true
viewof method = Inputs.select(
  ["jenks", "q6", "quantile", "equal", "msd"],
  {
    label: "method",
    value: "quantile"
  }
)
viewof nbreaks = Inputs.range([3, 9], { label: "nbreaks", step: 1, value: 7,  disabled: method == "msd" || method == "q6" ? true : false })
```

<br/>

```{ojs}
//| echo: false
//| eval: true
world03 = bertin.properties.add({
    geojson: world02, 
    field: "gdppc", 
    expression: "GDP/POP" 
})

bertin.draw({ layers: [ 
  {geojson: world03, fill: {type: "choro", values: "gdppc", method, nbreaks, colors: pal2, leg_x: 80, leg_y: 200, leg_title: "PIB par habitant", leg_round: 0}, tooltip:["$country", d => Math.round(d.properties.gdppc) +" $/hab"]}
  ] })
```

Bien s√ªr, avant de r√©aliser une carte choropl√®the, il est toujours n√©c√©ssaire de caract√©riser la distribution statistique.

Poutr cela, on peut utiliser la biblioth√®que `Plot`. Il y a plein de fa√ßons de faire.

### Les concepts de `Plot`

Il n'y a pas de type de graphique pr√©d√©fini, mais des marques, et des transformations qu'il est possible de combiner pour d√©ssiner n'importe quel type de graphique.

![](img/plot_concepts.png)

### Les marques

![](img/plot_marks.png)

### Les transformations

![](img/plot_transform.png)

### R√©cup√©rer la table attributaire

``` js
mytable = bertin.properties.table(world)
```

On la visualise

```{ojs}
Inputs.table(mytable)
```

```{ojs}
//| echo: false
//| eval: true
mytable = bertin.properties.table(world03)
```

### TickX

``` js
Plot.plot({
  marginTop: 10,
  marks: [
    Plot.tickX(mytable, { x: "gdppc" }),
  ]
})
```

<br/>

```{ojs}
//| echo: false
//| eval: true
Plot.plot({
  marginTop: 10,
  marks: [
    Plot.tickX(mytable, { x: "gdppc" }),
  ]
})
```

### Boxplot

``` js
Plot.plot({
  marks: [Plot.boxX(mytable, { x: "gdppc", fill: "red" })]
})
```

<br/>

```{ojs}
//| echo: false
//| eval: true
Plot.plot({
  marks: [Plot.boxX(mytable, { x: "gdppc", fill: "red" })]
})
```

### rectY

``` js
Plot.plot({
  marks: [
    Plot.rectY(
      mytable,
      Plot.binX({ y: "count" }, { x: "gdppc", thresholds: 5 })
    )
  ]
})
```

<br/>

```{ojs}
//| echo: false
//| eval: true
viewof thresholdsdiscr = Inputs.range([5, 100], { label: "Thresholds", step: 1 })
Plot.plot({
  height: 180,
  marks: [
    Plot.rectY(
      mytable,
      Plot.binX({ y: "count" }, { rx: 5, x: "gdppc", thresholds: thresholdsdiscr })
    ),
    Plot.ruleY([0])
  ]
})
```

### Dodge

``` js
Plot.plot({
  height: 340,
  marks: [
    Plot.dotX(
      mytable,
      Plot.dodgeY({ x: "gdppc"})
    )
  ]
})
```

<br/>

```{ojs}
//| echo: false
//| eval: true
Plot.plot({
  height: 340,
  marks: [
    Plot.dotX(
      mytable,
      Plot.dodgeY({ x: "gdppc", title: "name", fill: "red", padding: 0 })
    )
  ]
})
```

## Combinaisons

La biblioth√®que `bertin` est assez flexible. On peut donc faire des combinaisons.

### Supperposition de couches

La m√©thode la plus simple pour combiner des informations sur une carte est de supperposer des couches.

``` js
layers : [
  {type "bubble", geojson: world, values: "pop", fill: "none" }, // cercles
  {geojson: world, fill: { type: "typo", values: "regions" } } // typo
]
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ layers: [ 
   {type: "bubble", geojson: world02, values: "POP", fill: "none", stroke: "black", strokeWidth: 2},
  {geojson: world02, fill: {type: "typo", values: "subregiond"} }
  ] })

```

### Symboles color√©s (fill)

Mais on peut aussi faire varier la couleur de n'importe quel objet. Ici, sur le type `bubble`.

``` js
layers : [
  {
    type "bubble", 
    geojson: world,
    values: "pop",
    fill: { type: "typo", values: "regions" }
  }
]
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ layers: [ 
   {type: "bubble", geojson: world02, values: "POP", fill: {type: "typo", values: "subregiond"}},
    {geojson: world02, fill:"#CCC"}
  ] })

```

### Symboles color√©s (stroke)

Et ca fonctionne aussi pour les contours.

``` js
layers : [
  {
    type "bubble", 
    geojson: world,
    values: "pop",
    stroke: { type: "typo", values: "regions" },
    fill: "none"
  }
]
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ layers: [ 
   {type: "bubble", geojson: world02, values: "POP", stroke: {type: "typo", values: "subregiond"},strokeWidth: 2, fill:"none"},
    {geojson: world02, fill:"#CCC"}
  ] })

```

## Combiner 2 donn√©es de stock

Pour combiner 2 variables quantitatives absolues, on peut utiliser une repr√©sentation par double cercle. Ici, on va comparer population et PIB.

### Rendre les donn√©es comparables

Pour rendre les donn√©es comparables, on les exprime en % du total. Ca reste des donn√©es quantitatives absolues, mais exprim√©es en pourcentages.

On cr√©e donc 2 nouvelles variables : pop_pct et gdp_pct.

```{ojs}
world02bis = {
let data = bertin.properties.table(world02)
let poptot = d3.sum(data.map((d) => d.POP))
let gdptot = d3.sum(data.map((d) => d.GDP))

let data2 = data.map((d) => ({
  id: d.id,
  pop_pct: +((+d.POP / poptot) * 100).toFixed(2),
  gdp_pct: +((+d.GDP / gdptot) * 100).toFixed(2)
}))
return bertin.merge(world02, "id", data2, "id")
}
```

### Cartographie

Puis, on r√©alise la carte avec le type `mushroom`.

``` js
{
  type: "mushroom",
  geojson: world02bis,
  top_values: "gdp_pct",
  bottom_values: "pop_pct"
}
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ layers: [ 
   {type: "mushroom", geojson: world02bis,top_values: "gdp_pct",  bottom_values: "pop_pct",  leg_x: 50,
      leg_y: 160, leg_title: "Population\net richesse\ndans le Monde",       leg_top_fill: "none",
      leg_bottom_fill: "none",
      leg_top_txt: "PIB (%)",
      leg_bottom_txt: "POP (%)",
      leg_fontSize: 17, top_tooltip: { fields: ["$name", d => Math.round(d.properties.GDP/1000000000) + " milliards de $"], col: "#d64f4f" }, bottom_tooltip: {
        fields: ["$name", d => Math.round(d.properties.POP/1000000) + " millions d'habitants"],
        col: "#4fabd6"
      }},
    {geojson: world02, fill:"#CCC"}
  ] })

```

## Carte par points

La premi√®re carte de densit√© de points a √©t√© con√ßue par Armand Joseph Fr√®re de Montizon en 1830. Elle consiste √† d√©terminer la valeur d'un point et d'e placer autant de d'en placer le npmbre n√©c√©ssaire pour atteindre une quantit√©.

### M√©thode 1

De fa√ßon classique, on positionne les points de fa√ßon al√©atoire dans les mailles adminstratives.

``` js
{type: "dotdensity", geojson: world, values: "pop", dotvalue : 5000000}
```

<br/>

```{ojs}
//| echo: false
//| eval: true
bertin.draw({ layers: [ 
   {type: "dotdensity", geojson: world02, values: "POP", dotvalue: 5000000, symbol_size: 12, fill: "#F25842", stroke: "none"},
    {geojson: world02, fill:"#CCC"}
  ] })

```

Avec ce type de repr√©sentation, plus le maillage de d√©part est fin, plus la carte est efficace.

### M√©thode 2

Une autre m√©thode conssite √† positionner les points au centre des pays et de les √©carter √† la fa√ßon d'une cartogramme de Dorling.

``` js
{type: "dotcartogram", geojson: world, values: "pop", radius: r}
```

<br/>

```{ojs}
//| echo: false
//| eval: true
viewof rcartogram = Inputs.range([2, 10], {step: 1, value: 5, label: "rayon"})
bertin.draw({ layers: [ 
   {type: "dotcartogram", geojson: world02, values: "POP", fill: "#F25842", radius: rcartogram,  leg_x: 80,
        leg_y: 200,leg_title: "Population\nen 2019"},
    {geojson: world02, fill:"#CCC", stroke:"#CCC"}
  ] })

```

## Les grilles

La biblioth√®que `bertin` permet de passer de mailles irr√©guli√®res (maillage administratif) √† des mailles r√©guli√®res (carr√©s).

![](img/grid.png){\_}

Cela permet de r√©aliser de nouveaux types de repr√©sentation.

### Carroyage

Astuce : On peut prendre 2 variables de stock pour calculer directement le ratio. Ici, PIB par habitant.

``` js
{type : "regulargrid", geojson: world, values: ["gdp","pop"] }
```

<br/>

```{ojs}
//| echo: false
//| eval: true
viewof steprg = Inputs.range([10, 100], {value: 25, step: 5, label: "step"})
bertin.draw({ 
params: {margin: 20},
layers: [ 

   {type: "regulargrid", geojson: world02, values: ["GDP", "POP"], step: steprg, fill: { colors:  "Reds"},       tooltip: ["$id", "$value"],},
  ] })

```

### Points Bertin

Sur le m√™me principe, on peut r√©partir des masses r√©guli√®rement dans l'espace.

``` js
{type : "regularbubble", geojson: world, values: "pop", step: 20 }
```

Le r√©sultat ressemble √† des "points Bertin" qu'on peut param√©trer. <br/>

```{ojs}
//| echo: false
//| eval: true
viewof steppb = Inputs.range([10, 100], {value: 25, step: 5, label: "step"})
viewof kpb = Inputs.range([5, 50], {value: 15, step: 5, step: 5, label: "k"})
viewof dorlingpb = Inputs.toggle({label: "Dorling", value: false})
bertin.draw({ 
params: {margin: 20},
layers: [ 

   {type: "regularbubble", geojson: world02, values: "POP", step : steppb, k: kpb, fill:"#F25842", dorling: dorlingpb},
    {geojson: world02, fill:"#CCC", stroke: "#CCC"}
  ] })

```

Cela fonctionne √©gallement avec des carr√©s

``` js
{type : "regularsquare", geojson: world, values: "pop", step: 20 }
```

<br/>

```{ojs}
//| echo: false
//| eval: true
viewof steprs = Inputs.range([10, 100], {value: 25, step: 5, label: "step"})
viewof krs = Inputs.range([5, 50], {value: 15, step: 5, step: 5, label: "k"})
viewof dorlingrs = Inputs.toggle({label: "Demers", value: false})
bertin.draw({ 
params: {margin: 20},
layers: [ 

   {type: "regularsquare", geojson: world02, values: "POP", step : steprs, k: krs, fill:"#F25842", dorling: dorlingrs},
    {geojson: world02, fill:"#CCC", stroke: "#CCC"}
  ] })

```

### *Ridgelines*

Cette m√©thode de passage sur grille permet d'autres repr√©sentations plus exp√©rimentales.

``` js
{type : "ridge", geojson: world, values: "pop", step: 20 }
```

<br/>

```{ojs}
//| echo: false
//| eval: true
viewof stepr = Inputs.range([3, 30], {value: 5, step: 1, label: "Step"})
viewof blur = Inputs.range([0, 2], { label: "Blur", step: 0.01, value: 0 })
viewof hauteur = Inputs.range([30, 150], { label: "Hauteur", step: 5, value: 100 })
bertin.draw({ 
params: {margin: 20},
layers: [ 

    {
      type: "ridge",
      geojson: world02,
      fill:"#F25842",
      values: "POP",
      step: stepr,
      blur: blur,
      k: hauteur,
      operator: "mean",
      geoprocessing: "dotinpoly"
    },
    {geojson: world02, fill:"#CCC", stroke: "#CCC"}
  ] })

```

## Cartes de chaleur

La biblioth√®que `bertin` permet √©galement de faire de cartes liss√©es √† partir d'un semis de points ou de masses r√©aprties dans l'espace.

### A partir des centroides

``` js
{type: "smooth", values: "pop"}
```

<br/>

```{ojs}
//| echo: false
//| eval: true
viewof bandwidth = Inputs.range([2, 60], {
  step: 1,
  value: 20,
  label: "Bandwith"
})
viewof thresholds = Inputs.range([5, 150], {
  step: 1,
  value: 50,
  label: "Thresholds"
})
viewof clipsmooth1 = Inputs.toggle({ label: "Clip", value: false })
bertin.draw({ 
layers: [ 
{type: "bubble", geojson: world02, values: "POP", fill:"black", stroke: "none", k:15},

    {
      type: "smooth",
      geojson: world02,
      values: "POP",
      bandwidth: bandwidth,
      thresholds: thresholds,
      clip:clipsmooth1
    },
    {geojson: world02, fill:"#CCC", stroke: "#CCC"}
  ] })

```

### Via une grille

```{ojs}
//| echo: false
//| eval: true
viewof bandwidth2 = Inputs.range([2, 60], {
  step: 1,
  value: 20,
  label: "Bandwith"
})
viewof thresholds2 = Inputs.range([5, 150], {
  step: 1,
  value: 50,
  label: "Thresholds"
})
viewof smoothstep = Inputs.range([5, 50], {
  step: 1,
  value: 20,
  label: "Grille (step)"
})
viewof clipsmooth2 = Inputs.toggle({ label: "Clip", value: false })
bertin.draw({ 
layers: [ 
{type: "regularbubble", geojson: world02, values: "POP", fill:"black", stroke: "none", k:5, step: smoothstep},

    {
      type: "smooth",
      geojson: world02,
      values: "POP",
      grid_step : smoothstep,
      bandwidth: bandwidth2,
      thresholds: thresholds2,
      clip: clipsmooth2
    },
    {geojson: world02, fill:"#CCC", stroke: "#CCC"}
  ] })

```

## R√©cap'

![](img/types.jpeg){width:100%}

## Documentation

-   Le code source et la documentation complete de la librairie `bertin` est disponible ici : <https://github.com/neocarto/bertin>

-   Toutes les versions de la librairies sont accesibles sur npm : <https://www.npmjs.com/package/bertin>

-   De nombreux exemples sont accessibles sur la plateforme Observable : [https://observablehq.com/collection/\@neocartocnrs/bertin](https://observablehq.com/collection/@neocartocnrs/bertin)

![](img/doc_observable.png){width:100%}<br/>

## Bibliographie

-   Allaire J., Teague C., Scheidegger C., Xie Y., Dervieux C., (2022). Quarto (Version 1.2) \[Computer software\]. https://doi.org/10.5281/zenodo.5960048
-   Bostock M. (2021). Script for Data Analysis, https://towardsdatascience.com/javascript-for-data-analysis-2e8e7dbf63a7
-   Bostock M., Ogievetsky V., Heer J. (2011). D¬≥ Data-Driven Documents, IEEE, Volume: 17, https://ieeexplore.ieee.org/abstract/document/6064996
-   Grandjean M. (2022). La visualisation de donn√©es, entre usages d√©monstratifs et heuristiques.
-   Lambert N. (2022). La biblioth√®que bertin. https://observablehq.com/collection/@neocartocnrs/bertin
-   Perkel J.M. (2021). Reactive, reproducible, collaborative: computational notebooks evolve, https://www.nature.com/articles/d41586-021-01174-w
-   Tucker T. (2022). Classic Research in Data Visualization. https://observablehq.com/@tophtucker/classic-research-in-data-visualization

# Exercices

Mise en pratique de `bertin` dans Quarto

::: header
## TP1

<br/>Apprendre √† r√©aliser des cartes interactives<br/>avec Quarto et la biblioth√®que JavaScript `bertin` <br/>

![](img/tp1.png)
:::

::: header
## TP2

R√©aliser une *single page application* (dashboard) avec `bertin` et Quarto.

![](img/app.png)
:::

## 

::: columns
::: {.column width="10%"}
:::

::: {.column width="90%"}
<br/><br/><br/><br/><br/><br/>

## Contacts

<br/><b>Nicolas Lambert<br/>(France)</b><br/><br/> *nicolas.lambert\@cnrs.fr*<br/>https://twitter.com/neocartocnrs<br/>https://vis.social/@neocarto <br/>https://github.com/neocarto<br/>https://observablehq.com/@neocartocnrs

<b>Manhamady Puedraogo<br/>(Burkina Faso)</b><br/><br/> *nonresse\@gmail.com*
:::
:::
